package DP;

/**
 * 利用动态规划解决问题：有面值分别为1，3，5的三种硬币若干，凑成n元最少需要多少硬币？
 *
 * 在动态规划中有三个重要的元素：最优子结构，边界，状态转移公式
 */
public class CoinProblem {
    public static void main(String[] args) {
        System.out.println(coin(11));
    }

    private static int coin(int n) {
        //分析过程
        //先找规律：
        //凑成0元需要0个硬币：d(0) = 0
        //凑成1元需要1个1元硬币：d(1) = d(0) + 1 = 1
        //凑成2元需要2个1元硬币：d(2) = d(1) + 1 = 2
        //凑成3元需要3个1元硬币或者一个3元硬币，后者更少硬币，选后者：d(3) = min{d(2) + 1, d(3 - 3) + 1} = 1
        //凑成4元需要1个3元硬币，1个1元硬币：d(4) = d(3) + 1 = 2
        //凑成5元需要1个3元硬币，2个1元硬币或者1个5元硬币，这里选后者：d(5) = min{d(4) + 1, d(5 - 5) + 1} = 1
        //......
        //抽离出来，发现d(i) = min{d(i-1) + 1, d(i - vj) + 1},其中vj代表第j个硬币的面值，并且i - vj >= 0。
        //这里d(i-1)+1和d(i-vj)+1是d(i)的最优子结构，d(0)=0是边界，d(i)=min{ d(i-1)+1,d(i-vj)+1 }是状态转移公式。

        //程序实现
        n++;
        int[] d = new int[n];
        int[] vj = {1, 3, 5};
        d[0] = 0;   //边界

        for (int i = 1; i < n; i++) {   //计算d(1)到d(n-1)的值，注意前面n已经加了1
            d[i] = d[i-1] + 1;
            for (int j = 0; j < vj.length; j++) {
                if (i < vj[j]) {
                    break;  //不满足条件，退出此次循环
                }
                if (d[i - vj[j]] < d[i - 1]) {  //计算d(i) = min{d(i-1) + 1, d(i - vj) + 1}
                    d[i] = d[i - vj[j]] + 1;
                }
            }
        }

        return d[n-1];  //返回凑齐n元所需的最少硬币数
    }
}
